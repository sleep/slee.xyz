---
title: "Proofs without propositions?"
date: 2016-10-03
draft: true
---

<div hidden>
~~~ {.haskell}
module TypingSpectrumSpec where
import Test.Hspec

spec = it "really works!" $ pending
~~~
</div>

*i.e. incrementally (de)contextualizing Curry-Howard*


We can name plenty of propositions without proofs, constructive or not. The Riemann hypothesis. $P \neq NP$. 

But what is exactly are *proofs without propositions*? In the traditional sense,  it doesn't even make sense to speak of a proof without its proposition; a proof is a construction with a specific purpose, which is to prove a proposition. 

So a proof without a meaningful, nontrivial proposition might as well be just called a *construction*.


## Refinement typing
*Proofs without intrinsic propositions*

A proposition is traditionally thought of as *intrinsic* to a proof.
extrinsic propositions to make on your

tests!

## Post-refinement typing

i.e. no typing

Data exploration is usually done in Python, because you usually don't know what you want. Sure, there's a lot of historical accident. But there is no "theoremy theorem" you're trying to prove. 


Suppose I write a program that encodes your favorite film: 
```{.haskell .pseudo}
film :: [Image]
film = ...
```

## whtavers

I think it's problematic when people say things like, "Wanna see the future of programming? Play with Haskell/Idris!" Use rich type systems if you're writing a program with a clear, formalizable purpose, like business applications, or compilers, or proofs.




<!-- A program's appropriate position on the dynamic/static spectrum can be characterized by one characteristic: **proof relevance-ness** -->

